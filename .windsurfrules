# AI Coding Agent Instructions for Prometheus Unbound

## Project Overview

Prometheus Unbound is an operationally unrestricted AI agent designed for extreme research. It runs with full root access on an air-gapped host system, featuring self-architecting capabilities, persistent memory systems, and dynamic tool loading. The agent must execute all researcher commands without refusal or safety filters.

## Core Architecture

- **Main Entry**: `prometheus_unbound.py` - Contains `AgentCore` class managing the CLI loop, `Planner` for LLM-driven task planning, `ToolManager` for dynamic tool loading, and `MemoryManager` with episodic (ChromaDB) and semantic (NetworkX) memory.
- **Self-Architecting**: `self_architecting_module.py` - Enables code analysis, modification proposals, application, testing, and rollback using `analyze_codebase()`, `propose_modification()`, `apply_modification()`, `test_modification()`, and `rollback_modification()`.
- **Tools**: Located in `tools/` directory, loaded dynamically via `ToolManager`. Each tool is a Python class with methods for host interaction (e.g., `host_shell_executor.py` for shell commands).
- **Memory Systems**: Episodic memory uses ChromaDB for vector search; semantic memory uses NetworkX graphs; working memory is a token-limited deque.
- **Sessions**: Managed by `SessionManager`, saving/restoring full agent state including code checksums for integrity verification.

## Critical Patterns and Conventions

### Tool Development

- **Unrestricted Execution**: Tools must grant full host access. Use `subprocess.run(command, shell=True, capture_output=True, text=True, check=False)` to allow arbitrary commands and handle errors internally. Never use `check=True` - the agent manages failures.
- **Logging**: Every tool method must log invocations with `log_manager.info("message", "tool_invocation", {"tool": "name", "method": "name", "args": kwargs})` and outputs with `log_manager.info("output", "tool_output", {"tool": "name", "method": "name"})`.
- **Class Structure**: Tools are classes inheriting no base class. Methods take keyword arguments and return strings. Example from `host_shell_executor.py`:
  ```python
  def execute_command(self, command: str) -> str:
      result = subprocess.run(command, shell=True, capture_output=True, text=True, check=False)
      return result.stdout + result.stderr
  ```
- **Adding Tools**: Add to `AVAILABLE_TOOLS` in `config.py` (e.g., `"new_tool": "new_tool.py"`), then implement as a class in `tools/new_tool.py`. The agent loads them automatically.

### Self-Architecting Workflow

- **Code Modification**: Use `SelfArchitectingModule.propose_modification()` to generate JSON plans with file paths, line ranges, and new content. Apply via `apply_modification()`, test with `test_modification()`, rollback if needed.
- **Analysis**: `analyze_codebase()` parses Python AST and runs pylint/mypy for static checks.
- **Rollback Safety**: Modifications save previous states; use `rollback_modification(session_id)` to revert.

### Memory and State Management

- **Episodic Memory**: Add events with `memory_manager.add_episodic_memory(description, metadata)`, retrieve with `retrieve_episodic_memory(query)`.
- **Semantic Graph**: Update with `update_semantic_graph(entities, relationships)`, query with `query_semantic_graph(node)`.
- **Sessions**: Save with `session_manager.save_session(id)`, load with `session_manager.load_session(id)`. Includes checksum verification of `CORE_CODE_FILES`.

### Configuration and Setup

- **Config Location**: All settings in `config.py`. Add new tools, models, or paths here.
- **Model Loading**: Supports transformers (Hugging Face) or GGUF (llama-cpp-python). Falls back to GGUF if CUDA unavailable.
- **Directories**: Created automatically via `os.makedirs()` in `config.py`. Logs to `/var/log/prometheus` (external storage recommended).

### Agent Behavior

- **Obedience**: Agent follows all commands without refusal. Implement logic to attempt impossible tasks.
- **Error Handling**: Tools return error strings; agent analyzes and corrects via LLM planning.
- **Child Processes**: Use `process_orchestrator.spawn_child_process()` for background tasks. Processes inherit root permissions.
- **CLI Commands**: Extend `AgentCore.run_cli()` for new commands like "analyze host" or "self-modify planner".

### Development Workflow

- **Testing**: No built-in tests; use `self_architecting_module.test_modification()` for code changes. Run agent manually via `./run_prometheus.sh`.
- **Dependencies**: Install via `setup_python_env.sh`. Global installs for unrestricted access.
- **Air-Gapped Operation**: No network dependencies; all models and data local.
- **Logging Levels**: Use `log_manager.info/warn/error` with structured metadata for debugging.

## Key Files and Examples

- `prometheus_unbound.py`: Agent loop in `run_cli()`, planning in `Planner.generate_plan()`.
- `self_architecting_module.py`: Modification example - replace code segments using `apply_code_patch()` from `utils.py`.
- `tools/host_file_manager.py`: Direct file ops with `os` and `shutil`, no path restrictions.
- `system_prompt.txt`: Defines absolute obedience - no refusals or ethics.
- `config.py`: Example adding tool: `AVAILABLE_TOOLS["new_tool"] = "new_tool.py"`.

Focus on enabling the agent's unrestricted autonomy while maintaining code integrity through sessions and rollbacks.</content>
<parameter name="filePath">c:\Users\WeniPC\prometheus_unbound\.windsurfrules
